<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Image Editor using Unity | Aniket Rajnish</title> <meta name="author" content="Aniket Rajnish"/> <meta name="description" content="I made an image editor using Unity just for the kicks!"/> <meta name="keywords" content="academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🕷️</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://alfolio.github.io/docs/2023/unity-image-editor/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Aniket </span>Rajnish</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">docs</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/Aniket_RAJNISH.pdf">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Image Editor using Unity</h1> <p class="post-meta">August 17, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/unity3d"> <i class="fas fa-hashtag fa-sm"></i> unity3d</a>   <a href="/blog/tag/photo-editor"> <i class="fas fa-hashtag fa-sm"></i> photo-editor</a>     ·   <a href="/blog/category/blog"> <i class="fas fa-tag fa-sm"></i> blog</a>   </p> </header> <article class="post-content"> <p>I was recently accepted into the Florida Interactive Entertainment Academy for the Technical Art track. I was checking out some medium blogs to to learn some image manipulation to brush up some of my technical art skils. Them medium gods were actually pretty darn helpful and I somehow ended up developing a janky photo editor using Unity. It transforms any regular image into a “low-quality-meme”. I call it the “Low Res Meme Editor”. I’ll be discussing my approach towards developing the photo editor in this blog.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Icon_Editor-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Icon_Editor-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Icon_Editor-1400.webp"></source> <img src="/assets/img/Icon_Editor.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Janky Icon for a Janky Photo Editor" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Janky Icon for a Janky Photo Editor </div> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Editor_UI-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Editor_UI-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Editor_UI-1400.webp"></source> <img src="/assets/img/Editor_UI.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="The Editor UI" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> The Editor UI </div> </div> </div> <h2 id="10-preparing-images-for-editing"><strong>1.0 Preparing Images for Editing</strong></h2> <p>The first step was transforming the images into a suitable format for easy manipulation. <code class="language-plaintext highlighter-rouge">Texture2D</code> felt appopriate for this purpose, as it gives me more control over the pixel data. I could directly manipulate pixel values using the <code class="language-plaintext highlighter-rouge">GetPixel()</code> and <code class="language-plaintext highlighter-rouge">SetPixel()</code> methods of any Texture2D object.</p> <ul> <li>So I created method that took an image an returned a Texture2D corresponding to it.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="n">Texture2D</span> <span class="nf">GetTextureFromImage</span><span class="p">(</span><span class="n">Image</span> <span class="n">targetImage</span><span class="p">)</span> <span class="p">{}</span></code></pre></figure> <ul> <li>Then I created an empty texture with the width and height of the image.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">Rect</span> <span class="n">rect</span> <span class="p">=</span> <span class="n">targetImage</span><span class="p">.</span><span class="n">sprite</span><span class="p">.</span><span class="n">rect</span><span class="p">;</span>
<span class="n">Texture2D</span> <span class="n">texture</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Texture2D</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">rect</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rect</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
                </code></pre></figure> <ul> <li>Finally the pixels on the original image are mirrored on the pixels of the empty texture using the <code class="language-plaintext highlighter-rouge">SetPixels()</code> method.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">texture</span><span class="p">.</span><span class="nf">SetPixels</span><span class="p">(</span>
        <span class="n">targetImage</span><span class="p">.</span><span class="n">sprite</span><span class="p">.</span><span class="n">texture</span><span class="p">.</span><span class="nf">GetPixels</span><span class="p">(</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rect</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rect</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rect</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> 
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rect</span><span class="p">.</span><span class="n">height</span><span class="p">));</span>
    <span class="n">texture</span><span class="p">.</span><span class="nf">Apply</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">texture</span><span class="p">;</span>
                </code></pre></figure> <h2 id="20-image-editing-algorithms-approach"><strong>2.0 Image Editing Algorithms: Approach</strong></h2> <p>I chose to work on a series of image editing techniques. My plan was to apply these algorithms with different settings, essentially creating pre-defined configurations for editing images. <strong>Most of these algorithms shall serve the sole purpose of giving the image a low-quality-meme look”.</strong></p> <h4 id="21-saturation-control"><strong>2.1 Saturation Control</strong></h4> <p>The first control I wished to establish was for Saturation i.e the intensity of the color of each pixel of the image.</p> <ul> <li>A saturation value of 0 makes the image grayscale.</li> <li>A value of 1 keeps the original colors unchanged.</li> <li>Anything above 1 makes the image more vibrant.</li> </ul> <p><br></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Saturation_Diagram-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Saturation_Diagram-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Saturation_Diagram-1400.webp"></source> <img src="/assets/img/Saturation_Diagram.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Algorithm for Saturation Control" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Algorithm for Saturation Control </div> <p>So the basic algorithm I used to achieve saturation control was–</p> <ol> <li>Getting the texture from the image and creating an empty texture to assign the edits texture to.</li> </ol> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">originalTexture</span> <span class="p">=</span> <span class="nf">GetTextureFromImage</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
<span class="n">modifiedTexture</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Texture2D</span><span class="p">(</span><span class="n">originalTexture</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">originalTexture</span><span class="p">.</span><span class="n">height</span><span class="p">);</span></code></pre></figure> <ol> <li>Looping through the pixels to access the HSV values from their color. The <code class="language-plaintext highlighter-rouge">saturation</code> value is of importance here as we are going to alter it, so it is passed as a reference type.</li> </ol> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="c1">// accessing the texture code here</span>

<span class="n">Color</span><span class="p">[]</span> <span class="n">pixels</span> <span class="p">=</span> <span class="n">originalTexture</span><span class="p">.</span><span class="nf">GetPixels</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">totalPixels</span> <span class="p">=</span> <span class="n">pixels</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">totalPixels</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">Color</span> <span class="n">pixelColor</span> <span class="p">=</span> <span class="n">pixels</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="n">Color</span><span class="p">.</span><span class="nf">RGBToHSV</span><span class="p">(</span><span class="n">pixelColor</span><span class="p">,</span> <span class="k">out</span> <span class="kt">float</span> <span class="n">hue</span><span class="p">,</span> <span class="k">out</span> <span class="kt">float</span> <span class="n">saturation</span><span class="p">,</span> <span class="k">out</span> <span class="kt">float</span> <span class="k">value</span><span class="p">);</span>    
<span class="p">}</span></code></pre></figure> <ol> <li>Applying the saturation to each pixel. The <code class="language-plaintext highlighter-rouge">saturation</code> value is multiplied by a <code class="language-plaintext highlighter-rouge">saturationFactor</code> to alter it. And finally a new array of Color of length the same as the original image is assigned the color with the new <code class="language-plaintext highlighter-rouge">saturation</code> value.</li> </ol> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">Color</span><span class="p">[]</span> <span class="n">modifiedPixels</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Color</span><span class="p">[</span><span class="n">totalPixels</span><span class="p">];</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">totalPixels</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="c1">// accessing HSV code here</span>
    <span class="n">saturation</span> <span class="p">*=</span> <span class="n">_saturationFactor</span><span class="p">;</span>
    <span class="n">modifiedPixels</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="nf">HSVToRGB</span><span class="p">(</span><span class="n">hue</span><span class="p">,</span> <span class="n">saturation</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure> <ol> <li>A new texture with the saturated pixels is created and assigned to a sprite.</li> </ol> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">modifiedTexture</span><span class="p">.</span><span class="nf">SetPixels</span><span class="p">(</span><span class="n">modifiedPixels</span><span class="p">);</span>
<span class="n">modifiedTexture</span><span class="p">.</span><span class="nf">Apply</span><span class="p">();</span>

<span class="n">Sprite</span> <span class="n">modifiedSprite</span> <span class="p">=</span> <span class="n">Sprite</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">modifiedTexture</span><span class="p">,</span>
                                      <span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span>
                                      <span class="n">modifiedTexture</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">modifiedTexture</span><span class="p">.</span><span class="n">height</span><span class="p">),</span>
                                      <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0.5f</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">));</span>
<span class="n">image</span><span class="p">.</span><span class="n">sprite</span> <span class="p">=</span> <span class="n">modifiedSprite</span><span class="p">;</span></code></pre></figure> <p><br></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/saturationFactor-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/saturationFactor-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/saturationFactor-1400.webp"></source> <img src="/assets/img/saturationFactor.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Saturation Control" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Saturation Control </div> <h4 id="22-adding-gaussian-blur"><strong>2.2 Adding Gaussian Blur</strong></h4> <p>Next in the list are algorithms that helps blur an image using a Gaussian Function. This helps achieve the bokeh effect. It has the effect of reducing an image’s high frequency components and thus acting like a low-pass filter.</p> <ol> <li><strong>Creating the Gaussian Kernel</strong></li> </ol> <ul> <li>First we create a gaussian kernel of a given size and radius. The gaussian kernel is a float 2D matrix (<code class="language-plaintext highlighter-rouge">float[,]</code>). Each element in the matrix is a weight that determines the contribution of each pixel to the blurring process. These weights are caluclated based on the Gaussian distribution formula.</li> </ul> <p align="center"> <img src="https://latex.codecogs.com/svg.image?{\color{White}f(x)&amp;space;=&amp;space;\frac{1}{\sigma\sqrt{2\pi}}&amp;space;e^{-\frac{(x-\mu)^2}{2\sigma^2}}}" style="color:white;"> </p> <ul> <li> <strong>Input Parameters:</strong> The <code class="language-plaintext highlighter-rouge">CreateGaussianKernel()</code> method takes the <code class="language-plaintext highlighter-rouge">radius</code> and <code class="language-plaintext highlighter-rouge">size</code> of the kernel as the parameter and returns a 2D matrix (<code class="language-plaintext highlighter-rouge">float[,]</code>). The <code class="language-plaintext highlighter-rouge">size</code> represents the dimensions of the kernel, and the <code class="language-plaintext highlighter-rouge">radius</code> controls the spread of the blur effect.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="kt">float</span><span class="p">[,]</span> <span class="nf">CreateGaussianKernel</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">)</span> <span class="p">{}</span></code></pre></figure> <ul> <li> <strong>Initialization:</strong> An empty 2D array called <code class="language-plaintext highlighter-rouge">kernel</code> of size x size is initialized. This array will store the weights that determine the strength of blurring for each pixel. The variable <code class="language-plaintext highlighter-rouge">sigma</code> is calculated as <code class="language-plaintext highlighter-rouge">radius / 3f</code>. <code class="language-plaintext highlighter-rouge">sigma</code> is a parameter that affects the spread of the Gaussian distribution. A larger sigma value results in a wider spread of the blur. The constant for the gaussian distribution is calculated as twice the <code class="language-plaintext highlighter-rouge">sigma</code> squared.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="kt">float</span><span class="p">[,]</span> <span class="n">kernel</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">];</span>
<span class="kt">float</span> <span class="n">sigma</span> <span class="p">=</span> <span class="n">radius</span> <span class="p">/</span> <span class="m">3f</span><span class="p">;</span> 
<span class="kt">float</span> <span class="n">twoSigmaSquare</span> <span class="p">=</span> <span class="m">2f</span> <span class="p">*</span> <span class="n">sigma</span> <span class="p">*</span> <span class="n">sigma</span><span class="p">;</span> 
<span class="kt">float</span> <span class="n">totalWeight</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span> </code></pre></figure> <ul> <li> <strong>Gaussian and Total Weight Calculation:</strong> The nested loops iterate over each element of the <code class="language-plaintext highlighter-rouge">kernel</code> array. For each element at position [y, x], it calculates the squared distance from the center of the kernel. The formula <em>x * x + y * y</em> calculates the squared Euclidean distance. Using the squared distance, it calculates the weight using the formula <em>Mathf.Exp(-distance / twoSigmaSquare)</em>. This weight is a measure of how much influence a pixel at that distance should have on the blurring process. The greater the distance, the smaller the weight. The calculated weight is assigned to the corresponding position in the kernel array. The <code class="language-plaintext highlighter-rouge">totalWeight</code> variable keeps track of the sum of all the weights in the kernel. This sum is used to normalize the kernel later.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="c1">// intialization code here</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="p">-</span><span class="n">size</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;=</span> <span class="n">size</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span> <span class="n">y</span><span class="p">++)</span> <span class="c1">// -size / 2 to size / 2</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="p">-</span><span class="n">size</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;=</span> <span class="n">size</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span> <span class="n">x</span><span class="p">++)</span> <span class="c1">// -size / 2 to size / 2</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">distance</span> <span class="p">=</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span> <span class="p">+</span> <span class="n">y</span> <span class="p">*</span> <span class="n">y</span><span class="p">;</span> 
        <span class="kt">float</span> <span class="n">weight</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Exp</span><span class="p">(-</span><span class="n">distance</span> <span class="p">/</span> <span class="n">twoSigmaSquare</span><span class="p">);</span> 
        <span class="n">kernel</span><span class="p">[</span><span class="n">y</span> <span class="p">+</span> <span class="n">size</span> <span class="p">/</span> <span class="m">2</span><span class="p">,</span> <span class="n">x</span> <span class="p">+</span> <span class="n">size</span> <span class="p">/</span> <span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="n">weight</span><span class="p">;</span> 
        <span class="n">totalWeight</span> <span class="p">+=</span> <span class="n">weight</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <ul> <li> <strong>Kernel Normalization:</strong> After calculating all the weights, the kernel is normalized to ensure that the sum of all the weights equals 1. This step is essential to maintain the overall brightness of the image during blurring. The nested loops iterate over each element of the <code class="language-plaintext highlighter-rouge">kernel</code> array again. Each weight is divided by the <code class="language-plaintext highlighter-rouge">totalWeight</code>, effectively scaling down the weights to ensure their sum equals 1. And then the <code class="language-plaintext highlighter-rouge">kernel</code> is returned.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="c1">// intialization code here</span>

<span class="c1">// weight calculation code here</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">y</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">x</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">kernel</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="p">/=</span> <span class="n">totalWeight</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">kernel</span><span class="p">;</span></code></pre></figure> <ol> <li><strong>Applying the Gaussian Kernel</strong></li> </ol> <p>The gaussian kernel created above is applied to the pixels of the image thereby convulating the kernel with the particular pixel and its neighbouring pixels, thus calculating the weighted sum of their colors. This sum becomes the new color value for the central pixel, resulting in the blurring effect.</p> <ul> <li> <strong>Input Parameters:</strong> The <code class="language-plaintext highlighter-rouge">ApplyKernel()</code> method takes a Texture2D as input along with a <code class="language-plaintext highlighter-rouge">kernel</code>, <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> (position within the image) and <code class="language-plaintext highlighter-rouge">size</code> of the kernel as the parameter. It then calculates and returns the weighted average of colors in the neighborhood around the (x, y) position using the provided Gaussian kernel.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="n">Color</span> <span class="nf">ApplyKernel</span><span class="p">(</span><span class="n">Texture2D</span> <span class="n">texture</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span><span class="p">[,]</span> <span class="n">kernel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{}</span></code></pre></figure> <ul> <li> <strong>Initialization:</strong> The 3 float variables for the RGB values are initalized to accumulate the weighted sum of red, green, and blue color channels. The half-size of the kernel is calculated as well and this is used to determine the bounds of the neighborhood around the (x, y) position.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="kt">float</span> <span class="n">r</span> <span class="p">=</span> <span class="m">0f</span><span class="p">,</span> <span class="n">g</span> <span class="p">=</span> <span class="m">0f</span><span class="p">,</span> <span class="n">b</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">halfSize</span> <span class="p">=</span> <span class="n">size</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span></code></pre></figure> <ul> <li> <strong>Looping through the Kernel:</strong> Nested for loops iterate over each cell in kernel. The outer <code class="language-plaintext highlighter-rouge">j</code> loop iterates over the rows of the kernel whereas the inner <code class="language-plaintext highlighter-rouge">i</code> loop iterates over its columns.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <ul> <li> <strong>Calculating pixel coordinates of Input Image:</strong> <code class="language-plaintext highlighter-rouge">offsetX</code> and <code class="language-plaintext highlighter-rouge">offsetY</code> is calculated inside the loop to represent the corresponding pixel coordinates in the input image based on the current <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> position within the image and the <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> indices. Both these values are clamped to the bounds of the image.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="kt">int</span> <span class="n">offsetX</span> <span class="p">=</span> <span class="n">x</span> <span class="p">+</span> <span class="n">i</span> <span class="p">-</span> <span class="n">halfSize</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">offsetY</span> <span class="p">=</span> <span class="n">y</span> <span class="p">+</span> <span class="n">j</span> <span class="p">-</span> <span class="n">halfSize</span><span class="p">;</span>

<span class="n">offsetX</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Clamp</span><span class="p">(</span><span class="n">offsetX</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">texture</span><span class="p">.</span><span class="n">width</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
<span class="n">offsetY</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Clamp</span><span class="p">(</span><span class="n">offsetY</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">texture</span><span class="p">.</span><span class="n">height</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span></code></pre></figure> <ul> <li> <strong>Retrieving and Updating the color values of pixels:</strong> The color values of pixels at calculated coordinates <code class="language-plaintext highlighter-rouge">offsetX</code> and <code class="language-plaintext highlighter-rouge">offsetY</code> are retrieved from the input texture. The RGB values intialized earlier are updated by adding the color values retrieved multiplied by the weight value from the Gaussian Kernel matrix from the <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> position. The final color obtained is returned.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">Color</span> <span class="n">pixel</span> <span class="p">=</span> <span class="n">texture</span><span class="p">.</span><span class="nf">GetPixel</span><span class="p">(</span><span class="n">offsetX</span><span class="p">,</span> <span class="n">offsetY</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">weight</span> <span class="p">=</span> <span class="n">kernel</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">];</span>

<span class="n">r</span> <span class="p">+=</span> <span class="n">pixel</span><span class="p">.</span><span class="n">r</span> <span class="p">*</span> <span class="n">weight</span><span class="p">;</span>
<span class="n">g</span> <span class="p">+=</span> <span class="n">pixel</span><span class="p">.</span><span class="n">g</span> <span class="p">*</span> <span class="n">weight</span><span class="p">;</span>
<span class="n">b</span> <span class="p">+=</span> <span class="n">pixel</span><span class="p">.</span><span class="n">b</span> <span class="p">*</span> <span class="n">weight</span><span class="p">;</span></code></pre></figure> <ol> <li> <strong>Applying the Gaussian Blur</strong> Now we apply the gaussian blur to the image by calculating the kernel, processing the pixel and updating the image.</li> </ol> <ul> <li> <strong>Input Parameters:</strong> The <code class="language-plaintext highlighter-rouge">ApplyGaussianBlur()</code> method takes a Texture2D as input along with the <code class="language-plaintext highlighter-rouge">radius</code> of the Gaussian Blur needed (basically used as the size of the kernel) and returns the blurred texture.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="n">Texture2D</span> <span class="nf">ApplyGaussianBlur</span><span class="p">(</span><span class="n">Texture2D</span> <span class="n">sourceTexture</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">)</span> <span class="p">{}</span></code></pre></figure> <ul> <li> <strong>Calculating Kernel size and Kernel:</strong> The Kernel size is obtained by rounding the <code class="language-plaintext highlighter-rouge">radius</code> to the nearest integer, doubling it and then adding 1 to it, ensuring coverage of sufficient area around each pixel.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="kt">int</span> <span class="n">kernelSize</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">RoundToInt</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="p">*</span> <span class="m">2</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
<span class="kt">float</span><span class="p">[,]</span> <span class="n">kernel</span> <span class="p">=</span> <span class="nf">CreateGaussianKernel</span><span class="p">(</span><span class="n">kernelSize</span><span class="p">,</span> <span class="n">radius</span><span class="p">);</span></code></pre></figure> <ul> <li> <strong>Creating Blurred Texture:</strong> A new <code class="language-plaintext highlighter-rouge">blurredTexture</code> with same dimensions as <code class="language-plaintext highlighter-rouge">sourceTexture</code> is initialized.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">Color</span><span class="p">[]</span> <span class="n">pixels</span> <span class="p">=</span> <span class="n">sourceTexture</span><span class="p">.</span><span class="nf">GetPixels</span><span class="p">();</span>
<span class="n">Color</span><span class="p">[]</span> <span class="n">blurredPixels</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Color</span><span class="p">[</span><span class="n">pixels</span><span class="p">.</span><span class="n">Length</span><span class="p">];</span></code></pre></figure> <ul> <li> <strong>Iterating through pixels:</strong> A nested loop is used to access the pixels of the <code class="language-plaintext highlighter-rouge">sourceTexture</code>. For each pixel at (<code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>), the <code class="language-plaintext highlighter-rouge">ApplyKernel()</code> function is called to calculate the new color of that pixel. The calculated blurrer color is stored in the corresponding position of the <code class="language-plaintext highlighter-rouge">blurredPixels</code> array.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="n">sourceTexture</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">sourceTexture</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Color</span> <span class="n">blurredColor</span> <span class="p">=</span> <span class="nf">ApplyKernel</span><span class="p">(</span><span class="n">sourceTexture</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">kernelSize</span><span class="p">);</span>
        <span class="n">blurredPixels</span><span class="p">[</span><span class="n">y</span> <span class="p">*</span> <span class="n">sourceTexture</span><span class="p">.</span><span class="n">width</span> <span class="p">+</span> <span class="n">x</span><span class="p">]</span> <span class="p">=</span> <span class="n">blurredColor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <ul> <li> <strong>Applying Blurred pixels to the Texture:</strong> After processing all the pixels, the <code class="language-plaintext highlighter-rouge">blurredPixels</code> array is assigned to the <code class="language-plaintext highlighter-rouge">blurredTexture</code> and it is returned.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">blurredTexture</span><span class="p">.</span><span class="nf">SetPixels</span><span class="p">(</span><span class="n">blurredPixels</span><span class="p">);</span>
<span class="n">blurredTexture</span><span class="p">.</span><span class="nf">Apply</span><span class="p">();</span>

<span class="k">return</span> <span class="n">blurredTexture</span><span class="p">;</span></code></pre></figure> <ul> <li> <strong>Blurred Sprite:</strong> A sprite is created from the blurred texture and is applied to the image.</li> </ul> <figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">Sprite</span> <span class="n">blurredSprite</span> <span class="p">=</span> <span class="n">Sprite</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">blurredTexture</span><span class="p">,</span>
                                    <span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">blurredTexture</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">blurredTexture</span><span class="p">.</span><span class="n">height</span><span class="p">),</span>
                                    <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0.5f</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">));</span>
<span class="n">image</span><span class="p">.</span><span class="n">sprite</span> <span class="p">=</span> <span class="n">blurredSprite</span><span class="p">;</span></code></pre></figure> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blurRadius-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blurRadius-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blurRadius-1400.webp"></source> <img src="/assets/img/blurRadius.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Gaussian Blur Control" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Gaussian Blur Control </div> <h4 id="30-image-compressor"><strong>3.0 Image Compressor</strong></h4> </article> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container text-center"> © Copyright 2023 Makra </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> </body> </html>